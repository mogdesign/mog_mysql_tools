#!/bin/bash -f
#
# Author: Miroslav Vadkerti <miro.vadkerti at mogdesign.eu>
#

# globals
VERSION="0.4 (Dark Hawk)"
TOOLNAME=$(basename $0)
SYSTEM_CONFIG="/etc/$TOOLNAME.conf"
USER_CONFIG="$HOME/.$TOOLNAME.conf"
COMMAND=$1
SUBCOMMAND=$2

# defaults
MYSQL_HOST="localhost"
MYSQL_PORT="3306"
DEF_HOST="localhost"

#
# helpers
#
print_info() {
  echo ":: $1"
}

print_error() {
  echo "Error: $1"
}

exit_error() {
  print_error "$1"
  [ -n "$2" ] && { echo; $2; }
  exit 1
}

mysql_exec() {
  if [ -z "$1" ]; then
    mysql -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST \
      -P$MYSQL_PORT --skip-column-names
  else
    echo "$@" | mysql -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST \
      -P$MYSQL_PORT --skip-column-names
  fi
}

mysql_exec_db() {
  [ -z "$1" ] && exit_error "No database for $FUNCNAME"

  if [ -z "$2" ]; then
    mysql -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST \
      -P$MYSQL_PORT -D$1 --skip-column-names
  else
    echo ${@:2} | mysql -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST \
      -P$MYSQL_PORT -D$1 --skip-column-names
  fi
}

ask_user() {
  local INP=

  echo -n "$2: "
  read INP

  eval $1="$INP"
}

confirm() {
  local INP=

  [ -n "$CONFIRM" ] && return

  echo -n "$1 (y/n)? "

  read INP

  case $INP in
    y|Y)
      return
      ;;
    *)
      echo "Cancelled!"
      exit 1
  esac
}

# check if database exists
check_db() {
  command_db_list | egrep -q "^$1$"
  return $?
}

#
# general functions
#
sanity_checks() {
  # check mandatory config
  [ -z "$MYSQL_USER" ] && exit_error "No MySQL admin user in configuration"
  [ -z "$MYSQL_PASSWD" ] && exit_error "No MySQL admin password in configuration"

  # check mysql connection

  # check admin account requirements
}

load_config() {
  # load system-wide config
  if [ -e "$SYSTEM_CONFIG" ]; then
    source $SYSTEM_CONFIG
  fi

  # load config from home directory
  if [ -e "$USER_CONFIG" ]; then
    source $USER_CONFIG
  fi

  if [ ! -e "$USER_CONFIG" -a ! -e "$SYSTEM_CONFIG" ]; then
    echo "No configuration file found. Please create $USER_CONFIG"
    echo "or $SYSTEM_CONFIG file with at least these variables:"
    echo
    echo "# mysql administrator username and password"
    echo "MYSQL_USR=username"
    echo "MYSQL_PASSWD=password"
    echo
    echo "Refer to program help for more information"
    exit 0
  fi
}


show_help() {
  echo "Usage: $TOOLNAME command [sub-command] [options]"
  echo
  echo "MySQL command line tool for managing users, databases and displaying"
  echo "various useful information from MySQL database."
  echo
  echo "Run command without parameters to get detailed help."
  echo
  echo "Available commands:"
  echo " db          Manage and list databases"
  echo " shell       Get MySQL shell or execute SQL statement"
  echo " user        Manage and list users"
  echo
  echo
  echo "Configuration file:"
  echo " The configuration file provides basic configuration for $TOOLNAME tool."
  echo " Global configuration file is located at \`$SYSTEM_CONFIG'. This can be"
  echo " overriden by local configuration file \`~/.myctl.conf'. Configuration file"
  echo " contains bash varibles sourced by the tool."
  echo
  echo " Mandatory variables:"
  echo " MYSQL_USER      - MySQL administrator username" 
  echo " MYSQL_PASSWD  - MySQL administrator password" 
  echo
  echo " Optional variables:"
  echo " MYSQL_HOST      - MySQL hostname (default: localhost)" 
  echo " MYSQL_PORT      - MySQL port (default: 3309)" 
  echo " DEF_HOST        - Default host to add user (default: localhost)"
  echo " DEF_PASSWD    - Default password for added user"
  echo
  exit 0
}

#
# user management
#

## user command help
command_user() {
  echo "Usage: $TOOLNAME user [sub-command] [options]"
  echo
  echo "Available sub-commands:"
  echo "  add     Add new user"
  echo "  del     Delete user"
  echo "  list    List users with available databases"
  echo
  echo "Run sub-command with -h parameter to get detailed help."
  echo

  exit 0
}

## add user
command_user_add() {
  local OPTIND= DB= DUMP= PASSWD= UNAME=
  local PASSWD=$DEF_PASSWD
  local OPTS="hd:f:H:p:"

  while getopts $OPTS arg; do
    case $arg in
      h)
        user_add_help
        ;;
      d)
        DB=$OPTARG
        ;;
      f)
        DUMP=$OPTARG
        ;;
      p)
        PASSWD=$OPTARG
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  [ -z "$1" ] && exit_error "No username given" user_add_help
  [ $# -ne 1 ] && exit_error "Too many parameters" user_add_help
  [ -n "$DUMP" -a -z "$DB" ] && exit_error "No database given. Option -f requires -d" user_add_help
  [ -n "$DUMP" -a ! -e "$DUMP" ] && exit_error "Dump file '$DUMP' not found"

  IFS=@ read UNAME HOST <<< "$1"
  [ -z "$HOST" ] && HOST=$DEF_HOST

  # check if user already exists
  command_user_list "$UNAME@$HOST" &> /dev/null && \
    exit_error "User $UNAME@$HOST already exists"

  # check if database already exists
  mysql_exec "show databases;" | egrep -q "^$DB$" && exit_error \
    "Database $DB already exists, cannot create"

  # check if 

  while [ -z "$PASSWD" ]; do
    ask_user PASSWD "Enter '$UNAME@$HOST' password"
  done

  # add user
  SQL="CREATE USER '$UNAME'@'$HOST' IDENTIFIED BY '$PASSWD';"
  mysql_exec "$SQL" || exit_error "Addin user failed"
  print_info "Created user '$UNAME@$HOST' with password '$PASSWD'"

  # add database
  if [ -n "$DB" ]; then
    command_db_add -u "$UNAME@$HOST" $DB
  fi

  # restore dump from given file
  [ -n "$DUMP" ] && command_db_restore $DB $DUMP
}

user_add_help() {
  echo "Usage: $TOOLNAME user add [-d database] [-f dump] [-H host] [-p password] user[@host]"
  echo
  echo "Add new MySQL user who can connect from $DEF_HOST. Optionally specify other host, "
  echo "add also a new database and restore a MySQL dump from file."
  echo
  echo "Options:"
  echo " -d database       Create a user database with given name"
  echo " -f dump           Restore given dump to the database, requires -d"
  echo " -H host           Host user can authenticate from (default: $DEF_HOST)"
  echo " -p password       Use given password for user \
(default: ${DEF_PASSWD:-none, ask for password})"
  echo

  exit 0
}

## delete user
command_user_del() {
  local OPTIND= DBS= DALL= UNAME= HOST= DB=
  local OPTS="hDd:"

  while getopts $OPTS arg; do
    case $arg in
      h)
        user_del_help
        ;;
      d)
        DBS=$OPTARG
        ;;
      D)
        DALL=yes
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  [ -z "$1" ] && exit_error "No username given" user_del_help
  [ -n "$DBS" -a -n "$DALL" ] && exit_error \
    "Only one option for removing databases can be specified" user_del_help

  IFS=@ read UNAME HOST <<< "$1"
  [ -z "$HOST" ] && HOST=$DEF_HOST

  # check if user already exists
  command_user_list "\b$UNAME@$HOST\b" &> /dev/null || \
    exit_error "User $UNAME@$HOST does not exits"

  # check if any databases exists
  [ -n "$DALL" ] && command_user_list "$UNAME@$HOST" | grep -q "(none)" && \
    exit_error "No database exists for $UNAME@$HOST"

  # check if given databases exist for user
  if [ -n "$DBS" ]; then
    IFS=','
    for DB in $DBS; do
      command_user_list "\b$UNAME@$HOST\b[[:space:]]+$DB" &>/dev/null || \
        exit_error "Database $DB not found for $UNAME@$HOST"
    done
    unset IFS
  fi

  # ask for confirmation
  confirm "Really remove MySQL user $UNAME@$HOST"

  # delete user
  SQL="DROP USER '$UNAME'@'$HOST';"
  mysql_exec "$SQL" || exit_error "Adding user failed"
  print_info "User $UNAME@$HOST removed"

  exit 0
}

user_del_help() {
  echo "Usage: $TOOLNAME user del [-D] [-d db,..] user[@host]"
  echo
  echo "Remove given MySQL user connecting from $DEF_HOST. Optionally specify other host. "
  echo "Optionally remove all or given associated databases."
  echo
  echo "Options:"
  echo " -D                Remove all databases user has access to"
  echo " -d db,..          Remove one or more databases separated with a comma"
  echo

  exit 0
}

## list users
command_user_list() {
  local SQL= DATA= USER_HOST_DB= USR= HOST= DB= USRPREV= HOSTPREV= LIST=
  local FIRST= OPTIND=
  local OPTS="h"

  while getopts $OPTS arg; do
    case $arg in
      h)
        user_list_help
        ;;
      *)
        exit 1
        ;;
    esac
  done

  LIST=$(
    # get all users
    SQL="use mysql; SELECT DISTINCT user.user, user.host, db.db FROM user \
      left JOIN db ON user.user=db.user ORDER BY user, host, db"
    DATA=$(mysql_exec "$SQL")

    # for all users, hosts print their databases
    while read USER_HOST_DB; do
      read USR HOST DB <<< "$USER_HOST_DB"
      [ "$DB" = "NULL" ] && DB="(none)"
      if [ "$USR" = "$USRPREV" -a "$HOST" = "$HOSTPREV" ]; then
        echo -n "$DB "
        continue
      fi

      [ -z "$FIRST" ] && printf "%-40s%s" "$USR@$HOST" "$DB" || \
        printf "\n%-40s%s" "$USR@$HOST" "$DB "

      USRPREV=$USR
      HOSTPREV=$HOST
      FIRST="no"
    done <<< "$DATA" | sort | egrep "$1"
  )

  if [ -z "$LIST" ]; then
    echo "No data found"
    return 1
  fi

  {
    printf "%-40s%s\n" "User@Host" "Privileges to database(s)"
    printf "%80s\n" | tr ' ' -
    echo "$LIST"
  } | less -F
}

user_list_help() {
  echo "Usage: $TOOLNAME user list [REGEXP]"
  echo
  echo "List available mysql users with privilages to databases."
  echo "Currently the privileges are not distinguished."
  echo
  echo "Optionally a regular expressoin can be passwd to filter out results."
  echo "This REGEXP is passed to egrep directly."
  echo
  echo "Listed results are paged via less."

  exit 0
}


#
# database management
#

## db command help
command_db() {
  echo "Usage: $TOOLNAME db [sub-command] [options]"
  echo
  echo "MySQL database management."
  echo
  echo "Available sub-commands:"
  echo "  add      Add new database"
  echo "  del      Delete database"
  echo "  dump     Dump database contents"
  echo "  list     List databases"
  echo "  restore  Restore database from dump"
  echo
  echo "Run sub-command with -h parameter to get detailed help."
  echo

  exit 0
}

## list all databases
command_db_list() {
  local DBS=$(command_shell "show databases" | sort | egrep "$1")

  if [ -z "$DBS" ]; then
    echo "No database found"
    return 1
  fi

  {
    echo "Database"
    printf "%40s\n" | tr ' ' -
    echo "$DBS"
  } | less -F
}

db_list_help() {
  echo "Usage: $TOOLNAME db list [REGEXP]"
  echo
  echo "List available MySQL databases."
  echo
  echo "Optionally a regular expression can be passed to filter out results."
  echo "This REGEXP is passwd to egrep directly."
  echo
  echo "Listed results are paged via less."
  echo

  exit 0
}

## remove database
command_db_delete() { command_db_del $@; }
command_db_remove() { command_db_del $@; }
command_db_del() {
  local OPTS="h"

  while getopts $OPTS arg; do
    case $arg in
      h)
        db_del_help
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  # get positional param
  local DB=$1

  # sanity
  [ -z "$DB" ] && exit_error "No database given for removal" db_del_help
  [ $# -ne 1 ] && exit_error "Too many parameters" db_del_help

  # check if DB exists
  check_db "$DB" || exit_error "Database $DB does not exist"

  # confirm removal
  confirm "Really remove MySQL database $DB"

  # remove database
  command_shell "DROP DATABASE $DB"
  print_info "Database $DB removed"
}

db_del_help() {
  echo "Usage: $TOOLNAME db del database"
  echo
  echo "Remove given MySQL database."
  echo

  exit 0
}

## add database
command_db_create() { command_db_add $@; }
command_db_add() {
  local USRS= USR= UNAME= HOST= OPTIND=
  local OPTS="hu:f:"

  while getopts $OPTS arg; do
    case $arg in
      h)
        db_add_help
        ;;
      u)
        USRS="$USRS $OPTARG"
        ;;
      f)
        DUMP=$OPTARG
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  # get positional param
  local DB=$1

  # check if DB exists
  [ -z "$DB" ] && exit_error "No database name given" db_add_help
  [ $# -ne 1 ] && exit_error "Too many parameters" db_add_help
  check_db "$DB" && exit_error "Database $DB already exists"

  # dump file
  [ -n "$DUMP" -a ! -e "$DUMP" ] && exit_error "Dump file '$DUMP' not found"

  # check if given users exist
  if [ -n "$USRS" ]; then
    for USR in $USRS; do
      echo $USR | egrep -q ".+@.+" || exit_error \
        "User $USR has not form user@host"
      command_user_list | grep -q "$USR" || \
        exit_error "User $USR does not exist"
    done
  fi

  # add user
  SQL="CREATE DATABASE $DB"
  mysql_exec "$SQL" || exit_error "Creating database"
  print_info "Created database '$DB'"

  # grant all privileges to users
  if [ -n "$USRS" ]; then
    for USR in $USRS; do
      IFS=@ read UNAME HOST <<< "$USR"
      SQL="GRANT ALL ON $DB.* TO '$UNAME'@'$HOST';"
      mysql_exec "$SQL" || exit_error "Granting all privileges to database '$DB'"
      print_info "Granted all privileges for '$USR' to '$DB'"
    done
  fi

  # restore dump from given file
  [ -n "$DUMP" ] && command_db_restore $DB $DUMP
}

db_add_help() {
  echo "Usage: $TOOLNAME db add [options] DATABASE"
  echo
  echo "Add new database. Optionally grant all privileges for given existing user or more users."
  echo
  echo "Options:"
  echo " -f dump          Restore given dump to the database"
  echo " -u user@host     Grant all privileges for given users, can be specified multiple times"
  echo

  exit 0
}

## restore database
command_db_res() { command_db_restore $@; }
command_db_restore() {
  local OPTIND= REMOVE= FILEINFO=
  local OPTS="hr"

  while getopts $OPTS arg; do
    case $arg in
      h)
        db_restore_help
        ;;
      r)
        REMOVE=yes
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  # get positional params
  local DB=$1
  local DUMP=$2

  # check if DB exists
  [ -z "$DB" ] && exit_error "No database given" db_restore_help
  [ $# -ne 2 ] && exit_error "Restore needs 2 parameters" db_restore_help
  check_db "$DB" || exit_error "Database $DB does not exist"

  # check if dump exists
  [ -e "$DUMP" ] || exit_error "Dump file $DUMP not found"

  # truncate database if requested, do no ask confirmation
  if [ -n "$REMOVE" ]; then
    command_shell <<< "DROP DATABASE $DB; CREATE DATABASE $DB" || \
      exit_error "Failed to remove database contents"
    print_info "Removed database '$DB' contents"
  fi

  # try to restore
  FILEINFO=$(file -b $DUMP)
  case ${FILEINFO,,} in
    bzip2*) bunzip2 < $DUMP ;;
    gzip*) gunzip < $DUMP ;;
    zip*) unzip -p $DUMP ;;
    *) cat $DUMP ;;
  esac | mysql -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST $DB || \
    exit_error "Restoring dump $DUMP to $DB failed"

  # success :)
  print_info "Restored MySQL dump '$DUMP' to database '$DB'"
}

db_restore_help() {
  echo "Usage: $TOOLNAME db restore [options] DATABASE FILE"
  echo
  echo "Restore database contexts from given dump file. Optionally truncate"
  echo "database before restoring. The dump file can be uncompressed"
  echo "or compressed MySQL dump. Supported compression formats: gzip, zip"
  echo "and bzip2."
  echo
  echo "Options:"
  echo " -h          Show help"
  echo " -r          Drop all tables before restore"
  echo

  exit 0
}

## dump database
command_db_dump() {
  local OPTIND=
  local COMPRESS="gzip"
  local SUFFIX="sql.gz"
  local OPTS="hn"

  while getopts $OPTS arg; do
    case $arg in
      h)
        db_dump_help
        ;;
      n)
        COMPRESS="cat"
        SUFFIX="sql"
        ;;
      *)
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND-1))

  # get positional params
  local DB=$1
  local DUMP=$2

  # check if DB exists
  [ -z "$DB" ] && exit_error "No database given" db_dump_help
  [ $# -gt 2 ] && exit_error "Dump accepts one or two parameters" db_dump_help
  check_db "$DB" || exit_error "Database $DB does not exist"

  # check if dump exists or create a new filename
  if [ -n "$DUMP" ]; then
    [ -e "$DUMP" ] && exit_error "Dump file already exists"
  else
    DUMP="$DB-$(date +%Y%m%d_%H-%M).$SUFFIX"
  fi

  mysqldump -u$MYSQL_USER -p$MYSQL_PASSWD -h$MYSQL_HOST $DB | \
    $COMPRESS > $DUMP || exit_error "Dumping database '$DB' failed"

  # success :)
  print_info "Dumped database '$DB' to '$DUMP'"
}

db_dump_help() {
  echo "Usage: $TOOLNAME db dump [options] DATABASE [FILE]"
  echo
  echo "Dump database contexts to file. By default the dump is compressed"
  echo "via gzip and the the dump name is generated from database name and"
  echo "current data. Optionally the output FILE can be specified."
  echo "The compression can be disabled via the -n option."
  echo
  echo "Options:"
  echo " -h          Show help"
  echo " -n          Disable gzip compression"
  echo

  exit 0
}
#
# shell
#
command_shell() {
  local OPTS="hd:" OPTIND=
  local MEXEC="mysql_exec"
  local DB=

  while getopts $OPTS arg; do
    case $arg in
      h)
        shell_help
        ;;
      d)
        DB="$OPTARG"
        ;;
      *)
        exit 1
        ;;
    esac
  done
  shift $(($OPTIND-1))

  # check if db exists
  if [ -n "$DB" ]; then
    check_db $DB || exit_error "Database '$DB' does not exist"
    MEXEC="mysql_exec_db $DB"
  fi

  # run the shell
  if [ -z "$SUBCOMMAND" ]; then
    $MEXEC
  else
    $MEXEC "$@"
  fi

  return $?
}

shell_help() {
  echo "Usage: $TOOLNAME shell [options] [SQL]"
  echo
  echo "Get an administrator MySQL shell or execute given SQL."
  echo "Optionally use specified database."
  echo
  echo "Options:"
  echo " -h           Show help"
  echo " -d DATABASE  Run shell or execute command for given database."
  echo

  exit 0
}


#
# Main
#

# early help
{ [[ "$COMMAND" =~ (-h|--help) ]] || [ -z "$COMMAND" ]; } && show_help 

# answer yes
if [ "$COMMAND" = "-y" ]; then
  CONFIRM=yes
  shift
  COMMAND=$1
  SUBCOMMAND=$2
fi

# version
[[ "$COMMAND" =~ (-v|--version) ]] && { echo "Version: $VERSION"; exit 0; }

# load configuration
load_config

# sanity checks
sanity_checks

# shift away command and sub-command
shift 2

# execute give command specific function
if [ "$(type -t command_${COMMAND}_${SUBCOMMAND})" = function ]; then 
  command_${COMMAND}_${SUBCOMMAND} $@
  exit $?
elif [ "$(type -t command_${COMMAND})" = function ]; then
  command_$COMMAND $SUBCOMMAND $@
  exit $?
fi

exit_error "unknown command $COMMAND"

# vim: ai ts=2 sw=2 et
